---
created: 2023-05-03T15:56:56 (UTC +08:00)
tags: []
source: https://en.wikipedia.org/wiki/Scale-invariant_feature_transform
author: Contributors to Wikimedia projects
---

# Scale-invariant feature transform - Wikipedia

> ## Excerpt
> The scale-invariant feature transform (SIFT) is a computer vision algorithm to detect, describe, and match local features in images, invented by David Lowe in 1999.[1] Applications include object recognition, robotic mapping and navigation, image stitching, 3D modeling, gesture recognition, video tracking, individual identification of wildlife and match moving.

---
The **scale-invariant feature transform** (**SIFT**) is a [computer vision](https://en.wikipedia.org/wiki/Computer_vision "Computer vision") algorithm to detect, describe, and match local _[features](https://en.wikipedia.org/wiki/Feature_(computer_vision) "Feature (computer vision)")_ in images, invented by [David Lowe](https://en.wikipedia.org/wiki/David_G._Lowe "David G. Lowe") in 1999.<sup id="cite_ref-Lowe1999_1-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Lowe1999-1">[1]</a></sup> Applications include [object recognition](https://en.wikipedia.org/wiki/Outline_of_object_recognition "Outline of object recognition"), [robotic mapping](https://en.wikipedia.org/wiki/Robotic_mapping "Robotic mapping") and navigation, [image stitching](https://en.wikipedia.org/wiki/Image_stitching "Image stitching"), [3D modeling](https://en.wikipedia.org/wiki/3D_modeling "3D modeling"), [gesture recognition](https://en.wikipedia.org/wiki/Gesture_recognition "Gesture recognition"), [video tracking](https://en.wikipedia.org/wiki/Video_tracking "Video tracking"), individual identification of wildlife and [match moving](https://en.wikipedia.org/wiki/Match_moving "Match moving").

SIFT keypoints of objects are first extracted from a set of reference images<sup id="cite_ref-Lowe1999_1-1"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Lowe1999-1">[1]</a></sup> and stored in a database. An object is recognized in a new image by individually comparing each feature from the new image to this database and finding candidate matching features based on [Euclidean distance](https://en.wikipedia.org/wiki/Euclidean_distance "Euclidean distance") of their feature vectors. From the full set of matches, subsets of keypoints that agree on the object and its location, scale, and orientation in the new image are identified to filter out good matches. The determination of consistent clusters is performed rapidly by using an efficient [hash table](https://en.wikipedia.org/wiki/Hash_table "Hash table") implementation of the generalised [Hough transform](https://en.wikipedia.org/wiki/Hough_transform "Hough transform"). Each cluster of 3 or more features that agree on an object and its [pose](https://en.wikipedia.org/wiki/Pose_(computer_vision) "Pose (computer vision)") is then subject to further detailed model verification and subsequently outliers are discarded. Finally the probability that a particular set of features indicates the presence of an object is computed, given the accuracy of fit and number of probable false matches. Object matches that pass all these tests can be identified as correct with high confidence.<sup id="cite_ref-Lowe2004_2-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Lowe2004-2">[2]</a></sup>

## Overview\[[edit](https://en.wikipedia.org/w/index.php?title=Scale-invariant_feature_transform&action=edit&section=1 "Edit section: Overview")\]

For any object in an image, interesting points on the object can be extracted to provide a "feature description" of the object. This description, extracted from a training image, can then be used to identify the object when attempting to locate the object in a test image containing many other objects. To perform reliable recognition, it is important that the features extracted from the training image be detectable even under changes in image scale, noise and illumination. Such points usually lie on high-contrast regions of the image, such as object edges.

Another important characteristic of these features is that the relative positions between them in the original scene shouldn't change from one image to another. For example, if only the four corners of a door were used as features, they would work regardless of the door's position; but if points in the frame were also used, the recognition would fail if the door is opened or closed. Similarly, features located in articulated or flexible objects would typically not work if any change in their internal geometry happens between two images in the set being processed. However, in practice SIFT detects and uses a much larger number of features from the images, which reduces the contribution of the errors caused by these local variations in the average error of all feature matching errors.

SIFT<sup id="cite_ref-patent_3-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-patent-3">[3]</a></sup> can robustly identify objects even among clutter and under partial occlusion, because the SIFT feature descriptor is invariant to [uniform scaling](https://en.wikipedia.org/wiki/Scaling_(geometry) "Scaling (geometry)"), [orientation](https://en.wikipedia.org/wiki/Orientation_(geometry) "Orientation (geometry)"), illumination changes, and partially invariant to [affine distortion](https://en.wikipedia.org/wiki/Affine_transformation "Affine transformation").<sup id="cite_ref-Lowe1999_1-2"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Lowe1999-1">[1]</a></sup> This section summarizes the original SIFT algorithm and mentions a few competing techniques available for object recognition under clutter and partial occlusion.

The SIFT descriptor is based on image measurements in terms of _receptive fields_<sup id="cite_ref-KoeDoo87_4-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-KoeDoo87-4">[4]</a></sup><sup id="cite_ref-KoeDoo92_5-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-KoeDoo92-5">[5]</a></sup><sup id="cite_ref-Lin13BICY_6-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Lin13BICY-6">[6]</a></sup><sup id="cite_ref-Lin13-AdvImgPhy_7-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Lin13-AdvImgPhy-7">[7]</a></sup> over which _local scale invariant reference frames_<sup id="cite_ref-Lin13PONE_8-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Lin13PONE-8">[8]</a></sup><sup id="cite_ref-Lin14CompVis_9-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Lin14CompVis-9">[9]</a></sup> are established by _local scale selection_.<sup id="cite_ref-Lin94Book_10-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Lin94Book-10">[10]</a></sup><sup id="cite_ref-Lindeberg1998_11-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Lindeberg1998-11">[11]</a></sup><sup id="cite_ref-Lin14CompVis_9-1"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Lin14CompVis-9">[9]</a></sup> A general theoretical explanation about this is given in the Scholarpedia article on SIFT.<sup id="cite_ref-Lindeberg2012_12-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Lindeberg2012-12">[12]</a></sup>

| Problem | Technique | Advantage |
| --- | --- | --- |
| key localization / scale / rotation | [Difference of Gaussians](https://en.wikipedia.org/wiki/Difference_of_Gaussians "Difference of Gaussians") / [scale-space pyramid](https://en.wikipedia.org/wiki/Scale-space_representation "Scale-space representation") / orientation assignment | accuracy, stability, scale & rotational invariance |
| geometric distortion | blurring / resampling of local image orientation planes | affine invariance |
| indexing and matching | [nearest neighbor](https://en.wikipedia.org/wiki/Nearest_neighbor_search "Nearest neighbor search") / [Best Bin First](https://en.wikipedia.org/wiki/Best_Bin_First "Best Bin First") search | Efficiency / speed |
| Cluster identification | [Hough Transform](https://en.wikipedia.org/wiki/Hough_Transform "Hough Transform") voting | reliable [pose](https://en.wikipedia.org/wiki/Pose_(computer_vision) "Pose (computer vision)") models |
| Model verification / outlier detection | [Linear least squares](https://en.wikipedia.org/wiki/Linear_least_squares "Linear least squares") | better error tolerance with fewer matches |
| Hypothesis acceptance | [Bayesian Probability](https://en.wikipedia.org/wiki/Bayesian_Probability "Bayesian Probability") analysis | reliability |

### Types of features\[[edit](https://en.wikipedia.org/w/index.php?title=Scale-invariant_feature_transform&action=edit&section=2 "Edit section: Types of features")\]

The detection and description of local image features can help in object recognition. The SIFT features are local and based on the appearance of the object at particular interest points, and are invariant to image scale and rotation. They are also robust to changes in illumination, noise, and minor changes in viewpoint. In addition to these properties, they are highly distinctive, relatively easy to extract and allow for correct object identification with low probability of mismatch. They are relatively easy to match against a (large) database of local features but, however, the high dimensionality can be an issue, and generally probabilistic algorithms such as [k-d trees](https://en.wikipedia.org/wiki/K-d_tree "K-d tree") with [best bin first](https://en.wikipedia.org/wiki/Best_bin_first "Best bin first") search are used. Object description by set of SIFT features is also robust to partial occlusion; as few as 3 SIFT features from an object are enough to compute its location and pose. Recognition can be performed in close-to-real time, at least for small databases and on modern computer hardware.<sup>[<i><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (August 2008)">citation needed</span></a></i>]</sup>

## Main Stages\[[edit](https://en.wikipedia.org/w/index.php?title=Scale-invariant_feature_transform&action=edit&section=3 "Edit section: Main Stages")\]

### Scale-invariant feature detection\[[edit](https://en.wikipedia.org/w/index.php?title=Scale-invariant_feature_transform&action=edit&section=4 "Edit section: Scale-invariant feature detection")\]

Lowe's method for image feature generation transforms an image into a large collection of feature vectors, each of which is invariant to image translation, scaling, and rotation, partially invariant to illumination changes, and robust to local geometric distortion. These features share similar properties with neurons in the [primary visual cortex](https://en.wikipedia.org/wiki/Primary_visual_cortex "Primary visual cortex") that encode basic forms, color, and movement for object detection in primate vision.<sup id="cite_ref-Serre2005_13-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Serre2005-13">[13]</a></sup> Key locations are defined as maxima and minima of the result of [difference of Gaussians](https://en.wikipedia.org/wiki/Difference_of_Gaussians "Difference of Gaussians") function applied in [scale space](https://en.wikipedia.org/wiki/Scale_space "Scale space") to a series of smoothed and resampled images. Low-contrast candidate points and edge response points along an edge are discarded. Dominant orientations are assigned to localized key points. These steps ensure that the key points are more stable for matching and recognition. SIFT descriptors robust to local affine distortion are then obtained by considering pixels around a radius of the key location, blurring, and resampling local image orientation planes.

### Feature matching and indexing\[[edit](https://en.wikipedia.org/w/index.php?title=Scale-invariant_feature_transform&action=edit&section=5 "Edit section: Feature matching and indexing")\]

Indexing consists of storing SIFT keys and identifying matching keys from the new image. Lowe used a modification of the [k-d tree](https://en.wikipedia.org/wiki/K-d_tree "K-d tree") algorithm called the **[best-bin-first](https://en.wikipedia.org/wiki/Best_bin_first "Best bin first") search** method<sup id="cite_ref-Beis1997_14-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Beis1997-14">[14]</a></sup> that can identify the [nearest neighbors](https://en.wikipedia.org/wiki/Nearest_neighbor_search "Nearest neighbor search") with high probability using only a limited amount of computation. The BBF algorithm uses a modified search ordering for the [k-d tree](https://en.wikipedia.org/wiki/K-d_tree "K-d tree") algorithm so that bins in feature space are searched in the order of their closest distance from the query location. This search order requires the use of a [heap](https://en.wikipedia.org/wiki/Heap_(data_structure) "Heap (data structure)")\-based [priority queue](https://en.wikipedia.org/wiki/Priority_queue "Priority queue") for efficient determination of the search order. The best candidate match for each keypoint is found by identifying its nearest neighbor in the database of keypoints from training images. The nearest neighbors are defined as the keypoints with minimum [Euclidean distance](https://en.wikipedia.org/wiki/Euclidean_distance "Euclidean distance") from the given descriptor vector. The probability that a match is correct can be determined by taking the ratio of distance from the closest neighbor to the distance of the second closest.

Lowe<sup id="cite_ref-Lowe2004_2-1"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Lowe2004-2">[2]</a></sup> rejected all matches in which the distance ratio is greater than 0.8, which eliminates 90% of the false matches while discarding less than 5% of the correct matches. To further improve the efficiency of the best-bin-first algorithm search was cut off after checking the first 200 nearest neighbor candidates. For a database of 100,000 keypoints, this provides a speedup over exact nearest neighbor search by about 2 orders of magnitude, yet results in less than a 5% loss in the number of correct matches.

### Cluster identification by Hough transform voting\[[edit](https://en.wikipedia.org/w/index.php?title=Scale-invariant_feature_transform&action=edit&section=6 "Edit section: Cluster identification by Hough transform voting")\]

[Hough transform](https://en.wikipedia.org/wiki/Hough_transform "Hough transform") is used to cluster reliable model hypotheses to search for keys that agree upon a particular model [pose](https://en.wikipedia.org/wiki/Pose_(computer_vision) "Pose (computer vision)"). Hough transform identifies clusters of features with a consistent interpretation by using each feature to vote for all object poses that are consistent with the feature. When clusters of features are found to vote for the same pose of an object, the probability of the interpretation being correct is much higher than for any single feature. An entry in a [hash table](https://en.wikipedia.org/wiki/Hash_table "Hash table") is created predicting the model location, orientation, and scale from the match hypothesis. The [hash table](https://en.wikipedia.org/wiki/Hash_table "Hash table") is searched to identify all clusters of at least 3 entries in a bin, and the bins are sorted into decreasing order of size.

Each of the SIFT keypoints specifies 2D location, scale, and orientation, and each matched keypoint in the database has a record of its parameters relative to the training image in which it was found. The similarity transform implied by these 4 parameters is only an approximation to the full 6 degree-of-freedom pose space for a 3D object and also does not account for any non-rigid deformations. Therefore, Lowe<sup id="cite_ref-Lowe2004_2-2"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Lowe2004-2">[2]</a></sup> used broad bin sizes of 30 degrees for orientation, a factor of 2 for scale, and 0.25 times the maximum projected training image dimension (using the predicted scale) for location. The SIFT key samples generated at the larger scale are given twice the weight of those at the smaller scale. This means that the larger scale is in effect able to filter the most likely neighbors for checking at the smaller scale. This also improves recognition performance by giving more weight to the least-noisy scale. To avoid the problem of boundary effects in bin assignment, each keypoint match votes for the 2 closest bins in each dimension, giving a total of 16 entries for each hypothesis and further broadening the pose range.

### Model verification by linear least squares\[[edit](https://en.wikipedia.org/w/index.php?title=Scale-invariant_feature_transform&action=edit&section=7 "Edit section: Model verification by linear least squares")\]

Each identified cluster is then subject to a verification procedure in which a [linear least squares](https://en.wikipedia.org/wiki/Linear_least_squares_(mathematics) "Linear least squares (mathematics)") solution is performed for the parameters of the [affine transformation](https://en.wikipedia.org/wiki/Affine_transformation "Affine transformation") relating the model to the image. The affine transformation of a model point \[x y\]<sup>T</sup> to an image point \[u v\]<sup>T</sup> can be written as below

![{\displaystyle {\begin{bmatrix}u\\v\end{bmatrix}}={\begin{bmatrix}m_{1}&m_{2}\\m_{3}&m_{4}\end{bmatrix}}{\begin{bmatrix}x\\y\end{bmatrix}}+{\begin{bmatrix}t_{x}\\t_{y}\end{bmatrix}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/09ff18e65e3fc95ae57fa2b9d8ebca6635a791ad)

where the model translation is \[t<sub>x</sub> t<sub>y</sub>\]<sup>T</sup> and the affine rotation, scale, and stretch are represented by the parameters m<sub>1</sub>, m<sub>2</sub>, m<sub>3</sub> and m<sub>4</sub>. To solve for the transformation parameters the equation above can be rewritten to gather the unknowns into a column vector.

![{\begin{bmatrix}x&y&0&0&1&0\\0&0&x&y&0&1\\....\\....\end{bmatrix}}{\begin{bmatrix}m1\\m2\\m3\\m4\\tx\\ty\end{bmatrix}}={\begin{bmatrix}u\\v\\.\\.\end{bmatrix}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/842065473dc21abde901a7a3aa512e58a83bc1b8)

This equation shows a single match, but any number of further matches can be added, with each match contributing two more rows to the first and last matrix. At least 3 matches are needed to provide a solution. We can write this linear system as

![A{\hat  {{\mathbf  {x}}}}\approx {\mathbf  {b}},](https://wikimedia.org/api/rest_v1/media/math/render/svg/288fcceec6ccaad6fc8d3bb2d8b12d74f6732dce)

where _A_ is a known _m_\-by-_n_ [matrix](https://en.wikipedia.org/wiki/Matrix_(mathematics) "Matrix (mathematics)") (usually with _m_ > _n_), **x** is an unknown _n_\-dimensional parameter [vector](https://en.wikipedia.org/wiki/Vector_space "Vector space"), and **b** is a known _m_\-dimensional measurement vector.

Therefore, the minimizing vector ![{\hat {\mathbf {x} }}](https://wikimedia.org/api/rest_v1/media/math/render/svg/8a5451354f837d5d89774e1de386b44a903d929d) is a solution of the **normal equation**

![A^{T}\!A{\hat  {{\mathbf  {x}}}}=A^{T}{\mathbf  {b}}.](https://wikimedia.org/api/rest_v1/media/math/render/svg/68d4a149ce35f9cc0f7480781c222489246ffa36)

The solution of the system of linear equations is given in terms of the matrix ![(A^{T}A)^{{-1}}A^{T}](https://wikimedia.org/api/rest_v1/media/math/render/svg/a2bccc9d194b0a4b6190e48a91df2297d336a9e4), called the [pseudoinverse](https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse "Moore–Penrose inverse") of _A_, by

![{\hat  {{\mathbf  {x}}}}=(A^{T}\!A)^{{-1}}A^{T}{\mathbf  {b}}.](https://wikimedia.org/api/rest_v1/media/math/render/svg/3ee0011ccd88bc7077ef1b53d9115234d976cb7c)

which minimizes the sum of the squares of the distances from the projected model locations to the corresponding image locations.

### Outlier detection\[[edit](https://en.wikipedia.org/w/index.php?title=Scale-invariant_feature_transform&action=edit&section=8 "Edit section: Outlier detection")\]

[Outliers](https://en.wikipedia.org/wiki/Outlier "Outlier") can now be removed by checking for agreement between each image feature and the model, given the parameter solution. Given the [linear least squares](https://en.wikipedia.org/wiki/Linear_least_squares_(mathematics) "Linear least squares (mathematics)") solution, each match is required to agree within half the error range that was used for the parameters in the [Hough transform](https://en.wikipedia.org/wiki/Hough_transform "Hough transform") bins. As outliers are discarded, the linear least squares solution is re-solved with the remaining points, and the process iterated. If fewer than 3 points remain after discarding [outliers](https://en.wikipedia.org/wiki/Outlier "Outlier"), then the match is rejected. In addition, a top-down matching phase is used to add any further matches that agree with the projected model position, which may have been missed from the [Hough transform](https://en.wikipedia.org/wiki/Hough_transform "Hough transform") bin due to the similarity transform approximation or other errors.

The final decision to accept or reject a model hypothesis is based on a detailed probabilistic model.<sup id="cite_ref-Lowe2001_15-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Lowe2001-15">[15]</a></sup> This method first computes the expected number of false matches to the model pose, given the projected size of the model, the number of features within the region, and the accuracy of the fit. A [Bayesian probability](https://en.wikipedia.org/wiki/Bayesian_probability "Bayesian probability") analysis then gives the probability that the object is present based on the actual number of matching features found. A model is accepted if the final probability for a correct interpretation is greater than 0.98. Lowe's SIFT based object recognition gives excellent results except under wide illumination variations and under non-rigid transformations.

## Algorithm\[[edit](https://en.wikipedia.org/w/index.php?title=Scale-invariant_feature_transform&action=edit&section=9 "Edit section: Algorithm")\]

### Scale-space extrema detection\[[edit](https://en.wikipedia.org/w/index.php?title=Scale-invariant_feature_transform&action=edit&section=10 "Edit section: Scale-space extrema detection")\]

We begin by detecting points of interest, which are termed _keypoints_ in the SIFT framework. The image is [convolved](https://en.wikipedia.org/wiki/Convolution "Convolution") with Gaussian filters at different scales, and then the difference of successive [Gaussian-blurred](https://en.wikipedia.org/wiki/Gaussian_blur "Gaussian blur") images are taken. Keypoints are then taken as maxima/minima of the [Difference of Gaussians](https://en.wikipedia.org/wiki/Difference_of_Gaussians "Difference of Gaussians") (DoG) that occur at multiple scales. Specifically, a DoG image ![D\left(x,y,\sigma \right)](https://wikimedia.org/api/rest_v1/media/math/render/svg/32ebe4a50fbf3c7d09813ea35a1d049071b654cb) is given by

![D\left(x,y,\sigma \right)=L\left(x,y,k_{i}\sigma \right)-L\left(x,y,k_{j}\sigma \right)](https://wikimedia.org/api/rest_v1/media/math/render/svg/0c306d1f74e1df61c708529b9204c8983f455c1a),

where ![L\left(x,y,k\sigma \right)](https://wikimedia.org/api/rest_v1/media/math/render/svg/5cfd532a9a9875a56b7249a1ff194a5d2fbd357b) is the convolution of the original image ![I\left(x,y\right)](https://wikimedia.org/api/rest_v1/media/math/render/svg/7ff39cf100f86d733beab6a6048d2da9c98b4c0d) with the [Gaussian blur](https://en.wikipedia.org/wiki/Gaussian_blur "Gaussian blur") ![G\left(x,y,k\sigma \right)](https://wikimedia.org/api/rest_v1/media/math/render/svg/c93f3baf407b8cfbcb269c15274b35f70f241668) at scale ![k\sigma ](https://wikimedia.org/api/rest_v1/media/math/render/svg/27dc52b1580846852ed20e9a3149e67bc6b5de17), i.e.,

![L\left(x,y,k\sigma \right)=G\left(x,y,k\sigma \right)*I\left(x,y\right)](https://wikimedia.org/api/rest_v1/media/math/render/svg/19cebe04bb5bafad2217424d508467ea4aebabbc)

Hence a DoG image between scales ![k_{i}\sigma ](https://wikimedia.org/api/rest_v1/media/math/render/svg/d01edf96d4b6b75667ec0d0bac27448c99017418) and ![k_{j}\sigma ](https://wikimedia.org/api/rest_v1/media/math/render/svg/76a90d77762ecc743fd867acb7bfb403e651c515) is just the difference of the Gaussian-blurred images at scales ![k_{i}\sigma ](https://wikimedia.org/api/rest_v1/media/math/render/svg/d01edf96d4b6b75667ec0d0bac27448c99017418) and ![k_{j}\sigma ](https://wikimedia.org/api/rest_v1/media/math/render/svg/76a90d77762ecc743fd867acb7bfb403e651c515). For [scale space](https://en.wikipedia.org/wiki/Scale_space "Scale space") extrema detection in the SIFT algorithm, the image is first convolved with Gaussian-blurs at different scales. The convolved images are grouped by octave (an octave corresponds to doubling the value of ![\sigma ](https://wikimedia.org/api/rest_v1/media/math/render/svg/59f59b7c3e6fdb1d0365a494b81fb9a696138c36)), and the value of ![k_{i}](https://wikimedia.org/api/rest_v1/media/math/render/svg/f29138ed3ad54ffce527daccadc49c520459b0b0) is selected so that we obtain a fixed number of convolved images per octave. Then the Difference-of-Gaussian images are taken from adjacent Gaussian-blurred images per octave.

Once DoG images have been obtained, keypoints are identified as local minima/maxima of the DoG images across scales. This is done by comparing each pixel in the DoG images to its eight neighbors at the same scale and nine corresponding neighboring pixels in each of the neighboring scales. If the pixel value is the maximum or minimum among all compared pixels, it is selected as a candidate keypoint.

This keypoint detection step is a variation of one of the [blob detection](https://en.wikipedia.org/wiki/Blob_detection "Blob detection") methods developed by Lindeberg by detecting scale-space extrema of the scale normalized Laplacian;<sup id="cite_ref-Lin94Book_10-1"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Lin94Book-10">[10]</a></sup><sup id="cite_ref-Lindeberg1998_11-1"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Lindeberg1998-11">[11]</a></sup> that is, detecting points that are local extrema with respect to both space and scale, in the discrete case by comparisons with the nearest 26 neighbors in a discretized scale-space volume. The difference of Gaussians operator can be seen as an approximation to the Laplacian, with the implicit normalization in the [pyramid](https://en.wikipedia.org/wiki/Pyramid_(image_processing) "Pyramid (image processing)") also constituting a discrete approximation of the scale-normalized Laplacian.<sup id="cite_ref-Lindeberg2012_12-1"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Lindeberg2012-12">[12]</a></sup> Another real-time implementation of scale-space extrema of the Laplacian operator has been presented by Lindeberg and Bretzner based on a hybrid pyramid representation,<sup id="cite_ref-Lindenberg2003_16-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Lindenberg2003-16">[16]</a></sup> which was used for human-computer interaction by real-time gesture recognition in Bretzner et al. (2002).<sup id="cite_ref-17"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-17">[17]</a></sup>

### Keypoint localization\[[edit](https://en.wikipedia.org/w/index.php?title=Scale-invariant_feature_transform&action=edit&section=11 "Edit section: Keypoint localization")\]

[![](https://upload.wikimedia.org/wikipedia/commons/thumb/4/44/Sift_keypoints_filtering.jpg/220px-Sift_keypoints_filtering.jpg)](https://en.wikipedia.org/wiki/File:Sift_keypoints_filtering.jpg)

After scale space extrema are detected (their location being shown in the uppermost image) the SIFT algorithm discards low-contrast keypoints (remaining points are shown in the middle image) and then filters out those located on edges. Resulting set of keypoints is shown on last image.

Scale-space extrema detection produces too many keypoint candidates, some of which are unstable. The next step in the algorithm is to perform a detailed fit to the nearby data for accurate location, scale, and ratio of [principal curvatures](https://en.wikipedia.org/wiki/Principal_curvatures "Principal curvatures"). This information allows the rejection of points which are low contrast (and are therefore sensitive to noise) or poorly localized along an edge.

#### Interpolation of nearby data for accurate position\[[edit](https://en.wikipedia.org/w/index.php?title=Scale-invariant_feature_transform&action=edit&section=12 "Edit section: Interpolation of nearby data for accurate position")\]

First, for each candidate keypoint, interpolation of nearby data is used to accurately determine its position. The initial approach was to just locate each keypoint at the location and scale of the candidate keypoint.<sup id="cite_ref-Lowe1999_1-3"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Lowe1999-1">[1]</a></sup> The new approach calculates the interpolated location of the extremum, which substantially improves matching and stability.<sup id="cite_ref-Lowe2004_2-3"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Lowe2004-2">[2]</a></sup> The interpolation is done using the quadratic [Taylor expansion](https://en.wikipedia.org/wiki/Taylor_expansion "Taylor expansion") of the Difference-of-Gaussian scale-space function, ![D\left(x,y,\sigma \right)](https://wikimedia.org/api/rest_v1/media/math/render/svg/32ebe4a50fbf3c7d09813ea35a1d049071b654cb) with the candidate keypoint as the origin. This Taylor expansion is given by:

![{\displaystyle D({\textbf {x}})=D+{\frac {\partial D}{\partial {\textbf {x}}}}^{T}{\textbf {x}}+{\frac {1}{2}}{\textbf {x}}^{T}{\frac {\partial ^{2}D}{\partial {\textbf {x}}^{2}}}{\textbf {x}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/65581107b2a91a7954397710cd7c4ba64b89f33d)

where D and its derivatives are evaluated at the candidate keypoint and ![{\displaystyle {\textbf {x}}=\left(x,y,\sigma \right)^{T}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d02a39a13dda8d5524298f8e8a4b31bffa9b4455) is the offset from this point. The location of the extremum, ![{\hat  {{\textbf  {x}}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/a51ff2ef64578ad2d691347cba94d67b57c2e9ab), is determined by taking the derivative of this function with respect to ![{\textbf {x}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/85631435f001c884eca834164392982c621f40e2) and setting it to zero. If the offset ![{\hat  {{\textbf  {x}}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/a51ff2ef64578ad2d691347cba94d67b57c2e9ab) is larger than ![0.5](https://wikimedia.org/api/rest_v1/media/math/render/svg/c867fe7d5d53ce2c0790852289b794c6ed185f36) in any dimension, then that's an indication that the extremum lies closer to another candidate keypoint. In this case, the candidate keypoint is changed and the interpolation performed instead about that point. Otherwise the offset is added to its candidate keypoint to get the interpolated estimate for the location of the extremum. A similar subpixel determination of the locations of scale-space extrema is performed in the real-time implementation based on hybrid pyramids developed by Lindeberg and his co-workers.<sup id="cite_ref-Lindenberg2003_16-1"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Lindenberg2003-16">[16]</a></sup>

#### Discarding low-contrast keypoints\[[edit](https://en.wikipedia.org/w/index.php?title=Scale-invariant_feature_transform&action=edit&section=13 "Edit section: Discarding low-contrast keypoints")\]

To discard the keypoints with low contrast, the value of the second-order Taylor expansion ![D({\textbf  {x}})](https://wikimedia.org/api/rest_v1/media/math/render/svg/999fbffd563d66720a18ff91c66e7702d54e98b7) is computed at the offset ![{\hat  {{\textbf  {x}}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/a51ff2ef64578ad2d691347cba94d67b57c2e9ab). If this value is less than ![0.03](https://wikimedia.org/api/rest_v1/media/math/render/svg/e641feca9408a97498f074f3763b18cb359e6d49), the candidate keypoint is discarded. Otherwise it is kept, with final scale-space location ![{\textbf  {y}}+{\hat  {{\textbf  {x}}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/c8478657a4454df2961bcc2c2ae5211656be2eb0), where ![{\textbf {y}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/9217602eb948f6bfca224665a8b6aac54e15725b) is the original location of the keypoint.

#### Eliminating edge responses\[[edit](https://en.wikipedia.org/w/index.php?title=Scale-invariant_feature_transform&action=edit&section=14 "Edit section: Eliminating edge responses")\]

The DoG function will have strong responses along edges, even if the candidate keypoint is not robust to small amounts of noise. Therefore, in order to increase stability, we need to eliminate the keypoints that have poorly determined locations but have high edge responses.

For poorly defined peaks in the DoG function, the [principal curvature](https://en.wikipedia.org/wiki/Principal_curvature "Principal curvature") across the edge would be much larger than the principal curvature along it. Finding these principal curvatures amounts to solving for the [eigenvalues](https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors "Eigenvalues and eigenvectors") of the second-order [Hessian matrix](https://en.wikipedia.org/wiki/Hessian_matrix "Hessian matrix"), **H**:

![{\textbf  {H}}={\begin{bmatrix}D_{{xx}}&D_{{xy}}\\D_{{xy}}&D_{{yy}}\end{bmatrix}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/f5ae0e691c5916c803a823927fc73d2b4c07bcbd)

The eigenvalues of **H** are proportional to the principal curvatures of D. It turns out that the ratio of the two eigenvalues, say ![\alpha ](https://wikimedia.org/api/rest_v1/media/math/render/svg/b79333175c8b3f0840bfb4ec41b8072c83ea88d3) is the larger one, and ![\beta ](https://wikimedia.org/api/rest_v1/media/math/render/svg/7ed48a5e36207156fb792fa79d29925d2f7901e8) the smaller one, with ratio ![r=\alpha /\beta ](https://wikimedia.org/api/rest_v1/media/math/render/svg/a9917f45384a7dbe702bd5e3fe0302374867780b), is sufficient for SIFT's purposes. The trace of **H**, i.e., ![D_{{xx}}+D_{{yy}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/67155b93b6529c0525c538afdb73c629a39cc62e), gives us the sum of the two eigenvalues, while its determinant, i.e., ![D_{{xx}}D_{{yy}}-D_{{xy}}^{2}](https://wikimedia.org/api/rest_v1/media/math/render/svg/0ee0a396f7acd777ad05c60295800f5cd710d9d1), yields the product. The ratio ![{\text{R}}=\operatorname {Tr}({\textbf  {H}})^{2}/\operatorname {Det}({\textbf  {H}})](https://wikimedia.org/api/rest_v1/media/math/render/svg/c5ef3d007bd212c633c9cba89d324098892d2dd3) can be shown to be equal to ![(r+1)^{2}/r](https://wikimedia.org/api/rest_v1/media/math/render/svg/554d106d2a80bcc267cd98edbf41b824230245b0), which depends only on the ratio of the eigenvalues rather than their individual values. R is minimum when the eigenvalues are equal to each other. Therefore, the higher the [absolute difference](https://en.wikipedia.org/wiki/Absolute_difference "Absolute difference") between the two eigenvalues, which is equivalent to a higher absolute difference between the two principal curvatures of D, the higher the value of R. It follows that, for some threshold eigenvalue ratio ![r_{{{\text{th}}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/fb6b8271224198503ca3f7ae00885109c37d986d), if R for a candidate keypoint is larger than ![(r_{{{\text{th}}}}+1)^{2}/r_{{{\text{th}}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/73b660da2385d488a38f9835b7eac57ec556a3f5), that keypoint is poorly localized and hence rejected. The new approach uses ![r_{{{\text{th}}}}=10](https://wikimedia.org/api/rest_v1/media/math/render/svg/50a9a1e4b81a496d7162f7d1cd16cb0bc6ff24c9).<sup id="cite_ref-Lowe2004_2-4"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Lowe2004-2">[2]</a></sup>

This processing step for suppressing responses at edges is a transfer of a corresponding approach in the [Harris operator](https://en.wikipedia.org/wiki/Harris_corner_detector "Harris corner detector") for corner detection. The difference is that the measure for thresholding is computed from the Hessian matrix instead of a [second-moment matrix](https://en.wikipedia.org/wiki/Structure_tensor "Structure tensor").

### Orientation assignment\[[edit](https://en.wikipedia.org/w/index.php?title=Scale-invariant_feature_transform&action=edit&section=15 "Edit section: Orientation assignment")\]

In this step, each keypoint is assigned one or more orientations based on local image gradient directions. This is the key step in achieving [invariance to rotation](https://en.wikipedia.org/wiki/Rotational_invariance "Rotational invariance") as the keypoint descriptor can be represented relative to this orientation and therefore achieve invariance to image rotation.

First, the Gaussian-smoothed image ![L\left(x,y,\sigma \right)](https://wikimedia.org/api/rest_v1/media/math/render/svg/2563247cc6b706b24931d9929a76e1b7772f1f1f) at the keypoint's scale ![\sigma ](https://wikimedia.org/api/rest_v1/media/math/render/svg/59f59b7c3e6fdb1d0365a494b81fb9a696138c36) is taken so that all computations are performed in a scale-invariant manner. For an image sample ![L\left(x,y\right)](https://wikimedia.org/api/rest_v1/media/math/render/svg/a2ff6a1f58e33bc44be316d7b640bd66d7ad0bc3) at scale ![\sigma ](https://wikimedia.org/api/rest_v1/media/math/render/svg/59f59b7c3e6fdb1d0365a494b81fb9a696138c36), the gradient magnitude, ![m\left(x,y\right)](https://wikimedia.org/api/rest_v1/media/math/render/svg/5cf451cd06c180bb1b3085864ac77d7eb5b31899), and orientation, ![\theta \left(x,y\right)](https://wikimedia.org/api/rest_v1/media/math/render/svg/d6f1a3f26d22780c94396a15dbcbd5f9e41731ad), are precomputed using pixel differences:

![m\left(x,y\right)={\sqrt  {\left(L\left(x+1,y\right)-L\left(x-1,y\right)\right)^{2}+\left(L\left(x,y+1\right)-L\left(x,y-1\right)\right)^{2}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/6e7f16c462a58d1f1d261d760c6ba09dc050e9c9)

![\theta \left(x,y\right)={\mathrm  {atan2}}\left(L\left(x,y+1\right)-L\left(x,y-1\right),L\left(x+1,y\right)-L\left(x-1,y\right)\right)](https://wikimedia.org/api/rest_v1/media/math/render/svg/b25b22c4e7fc545545b10f78b50670f7769678e6)

The magnitude and direction calculations for the gradient are done for every pixel in a neighboring region around the keypoint in the Gaussian-blurred image L. An orientation histogram with 36 bins is formed, with each bin covering 10 degrees. Each sample in the neighboring window added to a histogram bin is weighted by its gradient magnitude and by a Gaussian-weighted circular window with a ![\sigma ](https://wikimedia.org/api/rest_v1/media/math/render/svg/59f59b7c3e6fdb1d0365a494b81fb9a696138c36) that is 1.5 times that of the scale of the keypoint. The peaks in this histogram correspond to dominant orientations. Once the histogram is filled, the orientations corresponding to the highest peak and local peaks that are within 80% of the highest peaks are assigned to the keypoint. In the case of multiple orientations being assigned, an additional keypoint is created having the same location and scale as the original keypoint for each additional orientation.

### Keypoint descriptor\[[edit](https://en.wikipedia.org/w/index.php?title=Scale-invariant_feature_transform&action=edit&section=16 "Edit section: Keypoint descriptor")\]

Previous steps found keypoint locations at particular scales and assigned orientations to them. This ensured invariance to image location, scale and rotation. Now we want to compute a descriptor vector for each keypoint such that the descriptor is highly distinctive and partially invariant to the remaining variations such as illumination, 3D viewpoint, etc. This step is performed on the image closest in scale to the keypoint's scale.

First a set of orientation histograms is created on 4×4 pixel neighborhoods with 8 bins each. These histograms are computed from magnitude and orientation values of samples in a 16×16 region around the keypoint such that each histogram contains samples from a 4×4 subregion of the original neighborhood region. The image gradient magnitudes and orientations are sampled around the keypoint location, using the scale of the keypoint to select the level of Gaussian blur for the image. In order to achieve orientation invariance, the coordinates of the descriptor and the gradient orientations are rotated relative to the keypoint orientation. The magnitudes are further weighted by a Gaussian function with ![\sigma ](https://wikimedia.org/api/rest_v1/media/math/render/svg/59f59b7c3e6fdb1d0365a494b81fb9a696138c36) equal to one half the width of the descriptor window. The descriptor then becomes a vector of all the values of these histograms. Since there are 4 × 4 = 16 histograms each with 8 bins the vector has 128 elements. This vector is then normalized to unit length in order to enhance invariance to affine changes in illumination. To reduce the effects of non-linear illumination a threshold of 0.2 is applied and the vector is again normalized. The thresholding process, also referred to as clamping, can improve matching results even when non-linear illumination effects are not present.<sup id="cite_ref-:0_18-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-:0-18">[18]</a></sup> The threshold of 0.2 was empirically chosen, and by replacing the fixed threshold with one systematically calculated, matching results can be improved.<sup id="cite_ref-:0_18-1"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-:0-18">[18]</a></sup>

Although the dimension of the descriptor, i.e. 128, seems high, descriptors with lower dimension than this don't perform as well across the range of matching tasks<sup id="cite_ref-Lowe2004_2-5"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Lowe2004-2">[2]</a></sup> and the computational cost remains low due to the approximate BBF (see below) method used for finding the nearest neighbor. Longer descriptors continue to do better but not by much and there is an additional danger of increased sensitivity to distortion and occlusion. It is also shown that feature matching accuracy is above 50% for viewpoint changes of up to 50 degrees. Therefore, SIFT descriptors are invariant to minor affine changes. To test the distinctiveness of the SIFT descriptors, matching accuracy is also measured against varying number of keypoints in the testing database, and it is shown that matching accuracy decreases only very slightly for very large database sizes, thus indicating that SIFT features are highly distinctive.

## Comparison of SIFT features with other local features\[[edit](https://en.wikipedia.org/w/index.php?title=Scale-invariant_feature_transform&action=edit&section=17 "Edit section: Comparison of SIFT features with other local features")\]

There has been an extensive study done on the performance evaluation of different local descriptors, including SIFT, using a range of detectors.<sup id="cite_ref-Mikolajczyk2005_19-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Mikolajczyk2005-19">[19]</a></sup> The main results are summarized below:

-   SIFT and SIFT-like [GLOH](https://en.wikipedia.org/wiki/GLOH "GLOH") features exhibit the highest matching accuracies ([recall](https://en.wikipedia.org/wiki/Recall_(information_retrieval) "Recall (information retrieval)") rates) for an affine transformation of 50 degrees. After this transformation limit, results start to become unreliable.
-   Distinctiveness of descriptors is measured by summing the eigenvalues of the descriptors, obtained by the [Principal components analysis](https://en.wikipedia.org/wiki/Principal_components_analysis "Principal components analysis") of the descriptors normalized by their variance. This corresponds to the amount of variance captured by different descriptors, therefore, to their distinctiveness. PCA-SIFT (Principal Components Analysis applied to SIFT descriptors), GLOH and SIFT features give the highest values.
-   SIFT-based descriptors outperform other contemporary local descriptors on both textured and structured scenes, with the difference in performance larger on the textured scene.
-   For scale changes in the range 2–2.5 and image rotations in the range 30 to 45 degrees, SIFT and SIFT-based descriptors again outperform other contemporary local descriptors with both textured and structured scene content.
-   Introduction of blur affects all local descriptors, especially those based on edges, like [shape context](https://en.wikipedia.org/wiki/Shape_context "Shape context"), because edges disappear in the case of a strong blur. But GLOH, PCA-SIFT and SIFT still performed better than the others. This is also true for evaluation in the case of illumination changes.

The evaluations carried out suggests strongly that SIFT-based descriptors, which are region-based, are the most robust and distinctive, and are therefore best suited for feature matching. However, most recent feature descriptors such as [SURF](https://en.wikipedia.org/wiki/Speeded_up_robust_features "Speeded up robust features") have not been evaluated in this study.

SURF has later been shown to have similar performance to SIFT, while at the same time being much faster.<sup id="cite_ref-SURF_20-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-SURF-20">[20]</a></sup> Other studies conclude that when speed is not critical, SIFT outperforms SURF.<sup id="cite_ref-Lin15JMIV_21-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Lin15JMIV-21">[21]</a></sup><sup id="cite_ref-SURFvsSIFT_22-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-SURFvsSIFT-22">[22]</a></sup> Specifically, disregarding discretization effects the pure image descriptor in SIFT is significantly better than the pure image descriptor in SURF, whereas the scale-space extrema of the determinant of the Hessian underlying the pure interest point detector in SURF constitute significantly better interest points compared to the scale-space extrema of the Laplacian to which the interest point detector in SIFT constitutes a numerical approximation.<sup id="cite_ref-Lin15JMIV_21-1"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Lin15JMIV-21">[21]</a></sup>

The performance of image matching by SIFT descriptors can be improved in the sense of achieving higher efficiency scores and lower 1-[precision](https://en.wikipedia.org/wiki/Precision_(information_retrieval) "Precision (information retrieval)") scores by replacing the scale-space extrema of the difference-of-Gaussians operator in original SIFT by scale-space extrema of the determinant of the Hessian, or more generally considering a more general family of generalized scale-space interest points.<sup id="cite_ref-Lin15JMIV_21-2"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Lin15JMIV-21">[21]</a></sup>

Recently, a slight variation of the descriptor employing an irregular histogram grid has been proposed that significantly improves its performance.<sup id="cite_ref-IrrGrid_23-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-IrrGrid-23">[23]</a></sup> Instead of using a 4×4 grid of histogram bins, all bins extend to the center of the feature. This improves the descriptor's robustness to scale changes.

The SIFT-Rank<sup id="cite_ref-Toews2009_24-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Toews2009-24">[24]</a></sup> descriptor was shown to improve the performance of the standard SIFT descriptor for affine feature matching. A SIFT-Rank descriptor is generated from a standard SIFT descriptor, by setting each histogram bin to its rank in a sorted array of bins. The Euclidean distance between SIFT-Rank descriptors is invariant to arbitrary monotonic changes in histogram bin values, and is related to [Spearman's rank correlation coefficient](https://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient "Spearman's rank correlation coefficient").

## Applications\[[edit](https://en.wikipedia.org/w/index.php?title=Scale-invariant_feature_transform&action=edit&section=18 "Edit section: Applications")\]

### Object recognition using SIFT features\[[edit](https://en.wikipedia.org/w/index.php?title=Scale-invariant_feature_transform&action=edit&section=19 "Edit section: Object recognition using SIFT features")\]

Given SIFT's ability to find distinctive keypoints that are invariant to location, scale and rotation, and robust to [affine transformations](https://en.wikipedia.org/wiki/Affine_transformation "Affine transformation") (changes in [scale](https://en.wikipedia.org/wiki/Linear_scale "Linear scale"), [rotation](https://en.wikipedia.org/wiki/Rotation "Rotation"), [shear](https://en.wikipedia.org/wiki/Shear_mapping "Shear mapping"), and position) and changes in illumination, they are usable for object recognition. The steps are given below.

-   First, SIFT features are obtained from the input image using the algorithm described above.
-   These features are matched to the SIFT feature database obtained from the training images. This feature matching is done through a Euclidean-distance based nearest neighbor approach. To increase robustness, matches are rejected for those keypoints for which the ratio of the nearest neighbor distance to the second-nearest neighbor distance is greater than 0.8. This discards many of the false matches arising from background clutter. Finally, to avoid the expensive search required for finding the Euclidean-distance-based nearest neighbor, an approximate algorithm called the best-bin-first algorithm is used.<sup id="cite_ref-Beis1997_14-1"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Beis1997-14">[14]</a></sup> This is a fast method for returning the nearest neighbor with high probability, and can give speedup by factor of 1000 while finding nearest neighbor (of interest) 95% of the time.
-   Although the distance ratio test described above discards many of the false matches arising from background clutter, we still have matches that belong to different objects. Therefore, to increase robustness to object identification, we want to cluster those features that belong to the same object and reject the matches that are left out in the clustering process. This is done using the [Hough transform](https://en.wikipedia.org/wiki/Hough_transform "Hough transform"). This will identify clusters of features that vote for the same object pose. When clusters of features are found to vote for the same pose of an object, the probability of the interpretation being correct is much higher than for any single feature. Each keypoint votes for the set of object poses that are consistent with the keypoint's location, scale, and orientation. _Bins_ that accumulate at least 3 votes are identified as candidate object/pose matches.
-   For each candidate cluster, a least-squares solution for the best estimated affine projection parameters relating the training image to the input image is obtained. If the projection of a keypoint through these parameters lies within half the error range that was used for the parameters in the Hough transform bins, the keypoint match is kept. If fewer than 3 points remain after discarding outliers for a bin, then the object match is rejected. The least-squares fitting is repeated until no more rejections take place. This works better for planar surface recognition than 3D object recognition since the affine model is no longer accurate for 3D objects.
-   In this journal,<sup id="cite_ref-Sirmacek2009_25-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Sirmacek2009-25">[25]</a></sup> authors proposed a new approach to use SIFT descriptors for multiple object detection purposes. The proposed multiple object detection approach is tested on aerial and satellite images.

SIFT features can essentially be applied to any task that requires identification of matching locations between images. Work has been done on applications such as recognition of particular object categories in 2D images, 3D reconstruction, motion tracking and segmentation, robot localization, image panorama stitching and [epipolar](https://en.wikipedia.org/wiki/Epipolar_geometry "Epipolar geometry") calibration. Some of these are discussed in more detail below.

### Robot localization and mapping\[[edit](https://en.wikipedia.org/w/index.php?title=Scale-invariant_feature_transform&action=edit&section=20 "Edit section: Robot localization and mapping")\]

In this application,<sup id="cite_ref-Se2001_26-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Se2001-26">[26]</a></sup> a trinocular stereo system is used to determine 3D estimates for keypoint locations. Keypoints are used only when they appear in all 3 images with consistent disparities, resulting in very few outliers. As the robot moves, it localizes itself using feature matches to the existing 3D map, and then incrementally adds features to the map while updating their 3D positions using a [Kalman filter](https://en.wikipedia.org/wiki/Kalman_filter "Kalman filter"). This provides a robust and accurate solution to the problem of robot localization in unknown environments. Recent 3D solvers leverage the use of keypoint directions to solve trinocular geometry from three keypoints<sup id="cite_ref-SIFTOrientationTrifocal_27-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-SIFTOrientationTrifocal-27">[27]</a></sup> and absolute pose from only two keypoints,<sup id="cite_ref-SIFTOrientationPose_28-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-SIFTOrientationPose-28">[28]</a></sup> an often disregarded but useful measurement available in SIFT. These orientation measurements reduce the number of required correspondences, further increasing robustness exponentially.

### Panorama stitching\[[edit](https://en.wikipedia.org/w/index.php?title=Scale-invariant_feature_transform&action=edit&section=21 "Edit section: Panorama stitching")\]

SIFT feature matching can be used in [image stitching](https://en.wikipedia.org/wiki/Image_stitching "Image stitching") for fully automated [panorama](https://en.wikipedia.org/wiki/Panorama "Panorama") reconstruction from non-panoramic images. The SIFT features extracted from the input images are matched against each other to find _k_ nearest-neighbors for each feature. These correspondences are then used to find _m_ candidate matching images for each image. [Homographies](https://en.wikipedia.org/wiki/Homography "Homography") between pairs of images are then computed using [RANSAC](https://en.wikipedia.org/wiki/Random_sample_consensus "Random sample consensus") and a probabilistic model is used for verification. Because there is no restriction on the input images, graph search is applied to find [connected components](https://en.wikipedia.org/wiki/Connected_component_(graph_theory) "Connected component (graph theory)") of image matches such that each connected component will correspond to a panorama. Finally for each connected component [bundle adjustment](https://en.wikipedia.org/wiki/Bundle_adjustment "Bundle adjustment") is performed to solve for joint camera parameters, and the panorama is rendered using [multi-band blending](https://en.wikipedia.org/w/index.php?title=Multi-band_blending&action=edit&redlink=1 "Multi-band blending (page does not exist)"). Because of the SIFT-inspired object recognition approach to panorama stitching, the resulting system is insensitive to the ordering, orientation, scale and illumination of the images. The input images can contain multiple panoramas and noise images (some of which may not even be part of the composite image), and panoramic sequences are recognized and rendered as output.<sup id="cite_ref-Brown2003_29-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Brown2003-29">[29]</a></sup>

### 3D scene modeling, recognition and tracking\[[edit](https://en.wikipedia.org/w/index.php?title=Scale-invariant_feature_transform&action=edit&section=22 "Edit section: 3D scene modeling, recognition and tracking")\]

This application uses SIFT features for [3D object recognition](https://en.wikipedia.org/wiki/3D_single-object_recognition "3D single-object recognition") and [3D modeling](https://en.wikipedia.org/wiki/3D_modeling "3D modeling") in context of [augmented reality](https://en.wikipedia.org/wiki/Augmented_reality "Augmented reality"), in which synthetic objects with accurate pose are superimposed on real images. SIFT matching is done for a number of 2D images of a scene or object taken from different angles. This is used with [bundle adjustment](https://en.wikipedia.org/wiki/Bundle_adjustment "Bundle adjustment") initialized from an [essential matrix](https://en.wikipedia.org/wiki/Essential_matrix "Essential matrix") or [trifocal tensor](https://en.wikipedia.org/wiki/Trifocal_tensor "Trifocal tensor") to build a sparse 3D model of the viewed scene and to simultaneously recover camera poses and [calibration](https://en.wikipedia.org/wiki/Geometric_camera_calibration "Geometric camera calibration") parameters. Then the position, orientation and size of the virtual object are defined relative to the coordinate frame of the recovered model. For online [match moving](https://en.wikipedia.org/wiki/Match_moving "Match moving"), SIFT features again are extracted from the current video frame and matched to the features already computed for the world model, resulting in a set of 2D-to-3D correspondences. These correspondences are then used to compute the current camera pose for the virtual projection and final rendering. A regularization technique is used to reduce the jitter in the virtual projection.<sup id="cite_ref-Gordon2006_30-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Gordon2006-30">[30]</a></sup> The use of SIFT directions have also been used to increase robustness of this process.<sup id="cite_ref-SIFTOrientationTrifocal_27-1"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-SIFTOrientationTrifocal-27">[27]</a></sup><sup id="cite_ref-SIFTOrientationPose_28-1"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-SIFTOrientationPose-28">[28]</a></sup> 3D extensions of SIFT have also been evaluated for [true 3D](https://en.wikipedia.org/wiki/True_3D "True 3D") object recognition and retrieval.<sup id="cite_ref-Flitton2010_31-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Flitton2010-31">[31]</a></sup><sup id="cite_ref-flitton13interestpoint_32-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-flitton13interestpoint-32">[32]</a></sup>

### 3D SIFT-like descriptors for human action recognition\[[edit](https://en.wikipedia.org/w/index.php?title=Scale-invariant_feature_transform&action=edit&section=23 "Edit section: 3D SIFT-like descriptors for human action recognition")\]

Extensions of the SIFT descriptor to 2+1-dimensional spatio-temporal data in context of [human action recognition](https://en.wikipedia.org/wiki/Human_action_recognition "Human action recognition") in video sequences have been studied.<sup id="cite_ref-Flitton2010_31-1"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Flitton2010-31">[31]</a></sup><sup id="cite_ref-Laptev2004_33-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Laptev2004-33">[33]</a></sup><sup id="cite_ref-Laptev2007_34-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Laptev2007-34">[34]</a></sup><sup id="cite_ref-Scovanner2007_35-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Scovanner2007-35">[35]</a></sup> The computation of local position-dependent histograms in the 2D SIFT algorithm are extended from two to three dimensions to describe SIFT features in a spatio-temporal domain. For application to human action recognition in a video sequence, sampling of the training videos is carried out either at spatio-temporal interest points or at randomly determined locations, times and scales. The spatio-temporal regions around these interest points are then described using the 3D SIFT descriptor. These descriptors are then clustered to form a spatio-temporal [Bag of words model](https://en.wikipedia.org/wiki/Bag_of_words_model "Bag of words model"). 3D SIFT descriptors extracted from the test videos are then matched against these _words_ for human action classification.

The authors report much better results with their 3D SIFT descriptor approach than with other approaches like simple 2D SIFT descriptors and Gradient Magnitude.<sup id="cite_ref-Niebles2006_36-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Niebles2006-36">[36]</a></sup>

### Analyzing the Human Brain in 3D Magnetic Resonance Images\[[edit](https://en.wikipedia.org/w/index.php?title=Scale-invariant_feature_transform&action=edit&section=24 "Edit section: Analyzing the Human Brain in 3D Magnetic Resonance Images")\]

The Feature-based [Morphometry](https://en.wikipedia.org/wiki/Brain_morphometry "Brain morphometry") (FBM) technique<sup id="cite_ref-Toews2010_37-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Toews2010-37">[37]</a></sup> uses extrema in a difference of Gaussian scale-space to analyze and classify 3D [magnetic resonance images](https://en.wikipedia.org/wiki/Magnetic_resonance_image "Magnetic resonance image") (MRIs) of the human brain. FBM models the image probabilistically as a collage of independent features, conditional on image geometry and group labels, e.g. healthy subjects and subjects with [Alzheimer's disease](https://en.wikipedia.org/wiki/Alzheimer%27s_disease "Alzheimer's disease") (AD). Features are first extracted in individual images from a 4D difference of Gaussian scale-space, then modeled in terms of their appearance, geometry and group co-occurrence statistics across a set of images. FBM was validated in the analysis of AD using a set of ~200 volumetric MRIs of the human brain, automatically identifying established indicators of AD in the brain and classifying mild AD in new images with a rate of 80%.<sup id="cite_ref-Toews2010_37-1"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Toews2010-37">[37]</a></sup>

## Competing methods\[[edit](https://en.wikipedia.org/w/index.php?title=Scale-invariant_feature_transform&action=edit&section=25 "Edit section: Competing methods")\]

Competing methods for scale invariant object recognition under clutter / partial occlusion include the following.

RIFT<sup id="cite_ref-Lazebnik2004_38-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Lazebnik2004-38">[38]</a></sup> is a rotation-invariant generalization of SIFT. The RIFT descriptor is constructed using circular normalized patches divided into concentric rings of equal width and within each ring a gradient orientation histogram is computed. To maintain rotation invariance, the orientation is measured at each point relative to the direction pointing outward from the center.

RootSIFT<sup id="cite_ref-Arandjelovic2012_39-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Arandjelovic2012-39">[39]</a></sup> is a variant of SIFT that modifies descriptor normalization. Since SIFT descriptors are histograms (and as such [probability distributions](https://en.wikipedia.org/wiki/Probability_distribution "Probability distribution")), employing [Euclidean distance](https://en.wikipedia.org/wiki/Euclidean_distance "Euclidean distance") to determine their similarity is not a natural choice. Comparing such descriptors using similarity measures tailored to probability distributions such as [Bhattacharyya coefficient](https://en.wikipedia.org/wiki/Bhattacharyya_coefficient "Bhattacharyya coefficient") (also known as Hellinger kernel) turns out to be more beneficial. For this purpose, the originally ![\ell ^{2}](https://wikimedia.org/api/rest_v1/media/math/render/svg/91f1f909abd70bd3d8fff0f7ae1ac23052387e18) normalized descriptor is first ![\ell ^{1}](https://wikimedia.org/api/rest_v1/media/math/render/svg/7d1156e1c2220628042b0fc51e0c73deb3b7c6d1) normalized and the square root of each element is computed followed by ![\ell ^{2}](https://wikimedia.org/api/rest_v1/media/math/render/svg/91f1f909abd70bd3d8fff0f7ae1ac23052387e18) renormalization. After these algebraic manipulations, RootSIFT descriptors can be normally compared using [Euclidean distance](https://en.wikipedia.org/wiki/Euclidean_distance "Euclidean distance") which is equivalent to using the Hellinger kernel on the original SIFT descriptors. This normalization scheme termed “L1-sqrt” was previously introduced for the block normalization of [HOG](https://en.wikipedia.org/wiki/Histogram_of_oriented_gradients "Histogram of oriented gradients") features whose rectangular block arrangement descriptor variant (R-HOG) is conceptually similar to the SIFT descriptor.

G-RIF:<sup id="cite_ref-Sungho2006_40-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Sungho2006-40">[40]</a></sup> Generalized Robust Invariant Feature is a general context descriptor which encodes edge orientation, edge density and [hue](https://en.wikipedia.org/wiki/Hue "Hue") information in a unified form combining perceptual information with spatial encoding. The object recognition scheme uses neighboring context based voting to estimate object models.

"[SURF](https://en.wikipedia.org/wiki/Speeded_up_robust_features "Speeded up robust features"):<sup id="cite_ref-Bay2006_41-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Bay2006-41">[41]</a></sup> Speeded Up Robust Features" is a high-performance scale- and rotation-invariant interest point detector / descriptor claimed to approximate or even outperform previously proposed schemes with respect to repeatability, distinctiveness, and robustness. SURF relies on [integral images](https://en.wikipedia.org/wiki/Integral_image "Integral image") for image convolutions to reduce computation time, builds on the strengths of the leading existing detectors and descriptors (using a fast [Hessian matrix](https://en.wikipedia.org/wiki/Hessian_matrix "Hessian matrix")\-based measure for the detector and a distribution-based descriptor). It describes a distribution of [Haar wavelet](https://en.wikipedia.org/wiki/Haar_wavelet "Haar wavelet") responses within the interest point neighborhood. Integral images are used for speed and only 64 dimensions are used reducing the time for feature computation and matching. The indexing step is based on the sign of the [Laplacian](https://en.wikipedia.org/wiki/Laplace_operator "Laplace operator"), which increases the matching speed and the robustness of the descriptor.

PCA-SIFT<sup id="cite_ref-Ke2004_42-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Ke2004-42">[42]</a></sup> and [GLOH](https://en.wikipedia.org/wiki/GLOH "GLOH")<sup id="cite_ref-Mikolajczyk2005_19-1"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Mikolajczyk2005-19">[19]</a></sup> are variants of SIFT. PCA-SIFT descriptor is a vector of image gradients in x and y direction computed within the support region. The gradient region is sampled at 39×39 locations, therefore the vector is of dimension 3042. The dimension is reduced to 36 with [PCA](https://en.wikipedia.org/wiki/Principal_component_analysis "Principal component analysis"). Gradient location-orientation histogram ([GLOH](https://en.wikipedia.org/wiki/GLOH "GLOH")) is an extension of the SIFT descriptor designed to increase its robustness and distinctiveness. The SIFT descriptor is computed for a log-polar location grid with three bins in radial direction (the radius set to 6, 11, and 15) and 8 in angular direction, which results in 17 location bins. The central bin is not divided in angular directions. The gradient orientations are quantized in 16 bins resulting in 272-bin histogram. The size of this descriptor is reduced with [PCA](https://en.wikipedia.org/wiki/Principal_component_analysis "Principal component analysis"). The [covariance matrix](https://en.wikipedia.org/wiki/Covariance_matrix "Covariance matrix") for [PCA](https://en.wikipedia.org/wiki/Principal_component_analysis "Principal component analysis") is estimated on image patches collected from various images. The 128 largest [eigenvectors](https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors "Eigenvalues and eigenvectors") are used for description.

Gauss-SIFT<sup id="cite_ref-Lin15JMIV_21-3"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Lin15JMIV-21">[21]</a></sup> is a pure image descriptor defined by performing all image measurements underlying the pure image descriptor in SIFT by Gaussian derivative responses as opposed to derivative approximations in an image pyramid as done in regular SIFT. In this way, discretization effects over space and scale can be reduced to a minimum allowing for potentially more accurate image descriptors. In Lindeberg (2015)<sup id="cite_ref-Lin15JMIV_21-4"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Lin15JMIV-21">[21]</a></sup> such pure Gauss-SIFT image descriptors were combined with a set of generalized scale-space interest points comprising the [Laplacian of the Gaussian](https://en.wikipedia.org/wiki/Laplacian_of_the_Gaussian "Laplacian of the Gaussian"), the [determinant of the Hessian](https://en.wikipedia.org/wiki/Determinant_of_the_Hessian "Determinant of the Hessian"), four new unsigned or signed [Hessian feature strength measures](https://en.wikipedia.org/wiki/Hessian_feature_strength_measures "Hessian feature strength measures") as well as [Harris-Laplace](https://en.wikipedia.org/wiki/Harris-Laplace_detector "Harris-Laplace detector") and [Shi-and-Tomasi](https://en.wikipedia.org/wiki/Shi-and-Tomasi "Shi-and-Tomasi") interests points. In an extensive experimental evaluation on a poster dataset comprising multiple views of 12 posters over scaling transformations up to a factor of 6 and viewing direction variations up to a slant angle of 45 degrees, it was shown that substantial increase in performance of image matching (higher efficiency scores and lower 1-[precision](https://en.wikipedia.org/wiki/Precision_(information_retrieval) "Precision (information retrieval)") scores) could be obtained by replacing Laplacian of Gaussian interest points by determinant of the Hessian interest points. Since difference-of-Gaussians interest points constitute a numerical approximation of Laplacian of the Gaussian interest points, this shows that a substantial increase in matching performance is possible by replacing the difference-of-Gaussians interest points in SIFT by determinant of the Hessian interest points. Additional increase in performance can furthermore be obtained by considering the unsigned Hessian feature strength measure ![{\displaystyle D_{1}L=\operatorname {det} HL-k\,\operatorname {trace} ^{2}HL\,{\mbox{if}}\operatorname {det} HL-k\,\operatorname {trace} ^{2}HL>0\,{\mbox{or 0 otherwise}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/552e8801cef2c539aceb7b254bb02938d94c49de). A quantitative comparison between the Gauss-SIFT descriptor and a corresponding Gauss-SURF descriptor did also show that Gauss-SIFT does generally perform significantly better than Gauss-SURF for a large number of different scale-space interest point detectors. This study therefore shows that discregarding discretization effects the pure image descriptor in SIFT is significantly better than the pure image descriptor in SURF, whereas the underlying interest point detector in SURF, which can be seen as numerical approximation to scale-space extrema of the determinant of the Hessian, is significantly better than the underlying interest point detector in SIFT.

Wagner et al. developed two object recognition algorithms especially designed with the limitations of current mobile phones in mind.<sup id="cite_ref-Wagner2008_43-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Wagner2008-43">[43]</a></sup> In contrast to the classic SIFT approach, Wagner et al. use the [FAST](https://en.wikipedia.org/wiki/Features_from_accelerated_segment_test "Features from accelerated segment test") corner detector for feature detection. The algorithm also distinguishes between the off-line preparation phase where features are created at different scale levels and the on-line phase where features are only created at the current fixed scale level of the phone's camera image. In addition, features are created from a fixed patch size of 15×15 pixels and form a SIFT descriptor with only 36 dimensions. The approach has been further extended by integrating a [Scalable Vocabulary Tree](https://en.wikipedia.org/w/index.php?title=Scalable_Vocabulary_Tree&action=edit&redlink=1 "Scalable Vocabulary Tree (page does not exist)") in the recognition pipeline.<sup id="cite_ref-Henze2009_44-0"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-Henze2009-44">[44]</a></sup> This allows the efficient recognition of a larger number of objects on mobile phones. The approach is mainly restricted by the amount of available [RAM](https://en.wikipedia.org/wiki/Random-access_memory "Random-access memory").

KAZE and A-KAZE _(KAZE Features and Accelerated-Kaze Features)_ is a new 2D feature detection and description method that perform better compared to SIFT and SURF. It gains a lot of popularity due to its open source code. KAZE was originally made by Pablo F. Alcantarilla, Adrien Bartoli and Andrew J. Davison.<sup id="cite_ref-45"><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_note-45">[45]</a></sup>

## See also\[[edit](https://en.wikipedia.org/w/index.php?title=Scale-invariant_feature_transform&action=edit&section=26 "Edit section: See also")\]

-   [Convolutional neural network](https://en.wikipedia.org/wiki/Convolutional_neural_network "Convolutional neural network")
-   [Image stitching](https://en.wikipedia.org/wiki/Image_stitching "Image stitching")
-   [Scale space](https://en.wikipedia.org/wiki/Scale_space "Scale space")
-   [Scale space implementation](https://en.wikipedia.org/wiki/Scale_space_implementation "Scale space implementation")
-   [Simultaneous localization and mapping](https://en.wikipedia.org/wiki/Simultaneous_localization_and_mapping "Simultaneous localization and mapping")
-   [Structure from motion](https://en.wikipedia.org/wiki/Structure_from_motion "Structure from motion")

## References\[[edit](https://en.wikipedia.org/w/index.php?title=Scale-invariant_feature_transform&action=edit&section=27 "Edit section: References")\]

1.  ^ [Jump up to: <sup><i><b>a</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Lowe1999_1-0) [<sup><i><b>b</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Lowe1999_1-1) [<sup><i><b>c</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Lowe1999_1-2) [<sup><i><b>d</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Lowe1999_1-3) Lowe, David G. (1999). ["Object recognition from local scale-invariant features"](http://www.cs.ubc.ca/~lowe/papers/iccv99.pdf) (PDF). _Proceedings of the International Conference on Computer Vision_. Vol. 2. pp. 1150–1157. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1109/ICCV.1999.790410](https://doi.org/10.1109%2FICCV.1999.790410).
2.  ^ [Jump up to: <sup><i><b>a</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Lowe2004_2-0) [<sup><i><b>b</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Lowe2004_2-1) [<sup><i><b>c</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Lowe2004_2-2) [<sup><i><b>d</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Lowe2004_2-3) [<sup><i><b>e</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Lowe2004_2-4) [<sup><i><b>f</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Lowe2004_2-5) Lowe, David G. (2004). ["Distinctive Image Features from Scale-Invariant Keypoints"](http://citeseer.ist.psu.edu/lowe04distinctive.html). _International Journal of Computer Vision_. **60** (2): 91–110. [CiteSeerX](https://en.wikipedia.org/wiki/CiteSeerX_(identifier) "CiteSeerX (identifier)") [10.1.1.73.2924](https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.73.2924). [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1023/B:VISI.0000029664.99615.94](https://doi.org/10.1023%2FB%3AVISI.0000029664.99615.94). [S2CID](https://en.wikipedia.org/wiki/S2CID_(identifier) "S2CID (identifier)") [221242327](https://api.semanticscholar.org/CorpusID:221242327).
3.  **[^](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-patent_3-0 "Jump up")** [U.S. Patent 6,711,293](https://patents.google.com/patent/US6711293), "Method and apparatus for identifying scale invariant features in an image and use of same for locating an object in an image", David Lowe's patent for the SIFT algorithm, March 23, 2004
4.  **[^](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-KoeDoo87_4-0 "Jump up")** Koenderink, Jan and van Doorn, Ans: "[Representation of local geometry in the visual system](http://www-prima.inrialpes.fr/perso/Tran/Documents/Articles/Divers/koenderink87.pdf)", Biological Cybernetics, vol 3, pp 383-396, 1987
5.  **[^](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-KoeDoo92_5-0 "Jump up")** Koenderink, Jan and van Doorn, Ans: "Generic neighbourhood operators", IEEE Transactions on Pattern Analysis and Machine Intelligence, vol 14, pp 597-605, 1992
6.  **[^](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Lin13BICY_6-0 "Jump up")** Lindeberg, Tony (December 1, 2013). ["A computational theory of visual receptive fields"](https://doi.org/10.1007/s00422-013-0569-z). _Biological Cybernetics_. **107** (6): 589–635. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1007/s00422-013-0569-z](https://doi.org/10.1007%2Fs00422-013-0569-z). [PMC](https://en.wikipedia.org/wiki/PMC_(identifier) "PMC (identifier)") [3840297](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3840297). [PMID](https://en.wikipedia.org/wiki/PMID_(identifier) "PMID (identifier)") [24197240](https://pubmed.ncbi.nlm.nih.gov/24197240) – via Springer Link.
7.  **[^](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Lin13-AdvImgPhy_7-0 "Jump up")** Lindeberg, Tony (2013). ["T. Generalized axiomatic scale-space theory"](https://www.sciencedirect.com/science/article/pii/B9780124077010000017). In Hawkes, Peter W. (ed.). [_Advances in Imaging and Electron Physics_](http://urn.kb.se/resolve?urn=urn:nbn:se:kth:diva-118695). Vol. 178. Elsevier. pp. 1–96. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1016/b978-0-12-407701-0.00001-7](https://doi.org/10.1016%2Fb978-0-12-407701-0.00001-7). [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)") [9780124077010](https://en.wikipedia.org/wiki/Special:BookSources/9780124077010 "Special:BookSources/9780124077010") – via ScienceDirect.
8.  **[^](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Lin13PONE_8-0 "Jump up")** Lindeberg, Tony (July 19, 2013). ["Invariance of visual operations at the level of receptive fields"](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3716821). _PLOS ONE_. **8** (7): e66990. [arXiv](https://en.wikipedia.org/wiki/ArXiv_(identifier) "ArXiv (identifier)"):[1210.0754](https://arxiv.org/abs/1210.0754). [Bibcode](https://en.wikipedia.org/wiki/Bibcode_(identifier) "Bibcode (identifier)"):[2013PLoSO...866990L](https://ui.adsabs.harvard.edu/abs/2013PLoSO...866990L). [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1371/journal.pone.0066990](https://doi.org/10.1371%2Fjournal.pone.0066990). [PMC](https://en.wikipedia.org/wiki/PMC_(identifier) "PMC (identifier)") [3716821](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3716821). [PMID](https://en.wikipedia.org/wiki/PMID_(identifier) "PMID (identifier)") [23894283](https://pubmed.ncbi.nlm.nih.gov/23894283).
9.  ^ [Jump up to: <sup><i><b>a</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Lin14CompVis_9-0) [<sup><i><b>b</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Lin14CompVis_9-1) T. Lindeberg (2014) ["Scale selection", Computer Vision: A Reference Guide, (K. Ikeuchi, Editor), Springer, pages 701-713.](http://kth.diva-portal.org/smash/record.jsf?pid=diva2%3A1392833&dswid=-9445)
10.  ^ [Jump up to: <sup><i><b>a</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Lin94Book_10-0) [<sup><i><b>b</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Lin94Book_10-1) [Lindeberg, T., Scale-Space Theory in Computer Vision, Kluwer Academic Publishers, 1994](http://www.csc.kth.se/~tony/book.html),[ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)") [0-7923-9418-6](https://en.wikipedia.org/wiki/Special:BookSources/0-7923-9418-6 "Special:BookSources/0-7923-9418-6")
11.  ^ [Jump up to: <sup><i><b>a</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Lindeberg1998_11-0) [<sup><i><b>b</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Lindeberg1998_11-1) Lindeberg, Tony (1998). ["Feature detection with automatic scale selection"](http://kth.diva-portal.org/smash/record.jsf?pid=diva2%3A453064&dswid=5931). _International Journal of Computer Vision_. **30** (2): 79–116. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1023/A:1008045108935](https://doi.org/10.1023%2FA%3A1008045108935). [S2CID](https://en.wikipedia.org/wiki/S2CID_(identifier) "S2CID (identifier)") [723210](https://api.semanticscholar.org/CorpusID:723210).
12.  ^ [Jump up to: <sup><i><b>a</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Lindeberg2012_12-0) [<sup><i><b>b</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Lindeberg2012_12-1) Lindeberg, Tony (2012). ["Scale invariant feature transform"](https://doi.org/10.4249%2Fscholarpedia.10491). _Scholarpedia_. **7** (5): 10491. [Bibcode](https://en.wikipedia.org/wiki/Bibcode_(identifier) "Bibcode (identifier)"):[2012SchpJ...710491L](https://ui.adsabs.harvard.edu/abs/2012SchpJ...710491L). [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.4249/scholarpedia.10491](https://doi.org/10.4249%2Fscholarpedia.10491).
13.  **[^](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Serre2005_13-0 "Jump up")** Serre, T., Kouh, M., Cadieu, C., Knoblich, U., Kreiman, G., Poggio, T., “[A Theory of Object Recognition: Computations and Circuits in the Feedforward Path of the Ventral Stream in Primate Visual Cortex](http://cbcl.mit.edu/projects/cbcl/publications/ai-publications/2005/AIM-2005-036.pdf)”, Computer Science and Artificial Intelligence Laboratory Technical Report, December 19, 2005 MIT-CSAIL-TR-2005-082.
14.  ^ [Jump up to: <sup><i><b>a</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Beis1997_14-0) [<sup><i><b>b</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Beis1997_14-1) Beis, J.; Lowe, David G. (1997). ["Shape indexing using approximate nearest-neighbour search in high-dimensional spaces"](http://www.cs.ubc.ca/~lowe/papers/cvpr97.pdf) (PDF). _Conference on Computer Vision and Pattern Recognition, Puerto Rico: sn_. pp. 1000–1006. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1109/CVPR.1997.609451](https://doi.org/10.1109%2FCVPR.1997.609451).
15.  **[^](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Lowe2001_15-0 "Jump up")** Lowe, D.G., [Local feature view clustering for 3D object recognition](http://www.cis.rit.edu/~cnspci/references/dip/feature_extraction/lowe2001.pdf). IEEE Conference on Computer Vision and Pattern Recognition, Kauai, Hawaii, 2001, pp. 682-688.
16.  ^ [Jump up to: <sup><i><b>a</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Lindenberg2003_16-0) [<sup><i><b>b</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Lindenberg2003_16-1) Lindeberg, Tony & Bretzner, Lars (2003). [_Real-time scale selection in hybrid multi-scale representations_](http://kth.diva-portal.org/smash/record.jsf?pid=diva2%3A440700&dswid=7232). _Proc. Scale-Space'03, Springer Lecture Notes in Computer Science_. Vol. 2695. pp. 148–163. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1007/3-540-44935-3\_11](https://doi.org/10.1007%2F3-540-44935-3_11). [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)") [978-3-540-40368-5](https://en.wikipedia.org/wiki/Special:BookSources/978-3-540-40368-5 "Special:BookSources/978-3-540-40368-5").
17.  **[^](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-17 "Jump up")** Lars Bretzner, Ivan Laptev, Tony Lindeberg ["Hand gesture recognition using multi-scale colour features, hierarchical models and particle filtering"](http://kth.diva-portal.org/smash/record.jsf?pid=diva2%3A462620&dswid=608), Proceedings of the Fifth IEEE International Conference on Automatic Face and Gesture Recognition, Washington, DC, USA, 21–21 May 2002, pages 423-428. [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)") [0-7695-1602-5](https://en.wikipedia.org/wiki/Special:BookSources/0-7695-1602-5 "Special:BookSources/0-7695-1602-5"), [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1109/AFGR.2002.1004190](https://doi.org/10.1109%2FAFGR.2002.1004190)
18.  ^ [Jump up to: <sup><i><b>a</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-:0_18-0) [<sup><i><b>b</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-:0_18-1) Kirchner, Matthew R. "[Automatic thresholding of SIFT descriptors](https://arxiv.org/abs/1811.03173)." In _Image Processing (ICIP), 2016 IEEE International Conference on_, pp. 291-295. IEEE, 2016.
19.  ^ [Jump up to: <sup><i><b>a</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Mikolajczyk2005_19-0) [<sup><i><b>b</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Mikolajczyk2005_19-1) Mikolajczyk, K.; Schmid, C. (2005). ["A performance evaluation of local descriptors"](http://research.microsoft.com/users/manik/projects/trade-off/papers/MikolajczykPAMI05.pdf) (PDF). _IEEE Transactions on Pattern Analysis and Machine Intelligence_. **27** (10): 1615–1630. [CiteSeerX](https://en.wikipedia.org/wiki/CiteSeerX_(identifier) "CiteSeerX (identifier)") [10.1.1.230.255](https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.230.255). [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1109/TPAMI.2005.188](https://doi.org/10.1109%2FTPAMI.2005.188). [PMID](https://en.wikipedia.org/wiki/PMID_(identifier) "PMID (identifier)") [16237996](https://pubmed.ncbi.nlm.nih.gov/16237996).
20.  **[^](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-SURF_20-0 "Jump up")** ["TU-chemnitz.de"](http://www.tu-chemnitz.de/etit/proaut/rsrc/iav07-surf.pdf) (PDF).
21.  ^ [Jump up to: <sup><i><b>a</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Lin15JMIV_21-0) [<sup><i><b>b</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Lin15JMIV_21-1) [<sup><i><b>c</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Lin15JMIV_21-2) [<sup><i><b>d</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Lin15JMIV_21-3) [<sup><i><b>e</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Lin15JMIV_21-4) Lindeberg, Tony (May 1, 2015). ["Image Matching Using Generalized Scale-Space Interest Points"](https://doi.org/10.1007/s10851-014-0541-0). _Journal of Mathematical Imaging and Vision_. **52** (1): 3–36. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1007/s10851-014-0541-0](https://doi.org/10.1007%2Fs10851-014-0541-0). [S2CID](https://en.wikipedia.org/wiki/S2CID_(identifier) "S2CID (identifier)") [254657377](https://api.semanticscholar.org/CorpusID:254657377) – via Springer Link.
22.  **[^](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-SURFvsSIFT_22-0 "Jump up")** Edouard Oyallon, Julien Rabin, "[An Analysis and Implementation of the SURF Method, and its Comparison to SIFT](http://www.ipol.im/pub/pre/69/)", Image Processing On Line
23.  **[^](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-IrrGrid_23-0 "Jump up")** Cui, Y.; Hasler, N.; Thormaehlen, T.; Seidel, H.-P. (July 2009). ["Scale Invariant Feature Transform with Irregular Orientation Histogram Binning"](http://www.mpi-inf.mpg.de/~hasler/download/CuiHasThoSei09igSIFT.pdf) (PDF). _Proceedings of the International Conference on Image Analysis and Recognition (ICIAR 2009)_. Halifax, Canada: Springer.
24.  **[^](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Toews2009_24-0 "Jump up")** Matthew Toews; William M. Wells III (2009). ["SIFT-Rank: Ordinal Descriptors for Invariant Feature Correspondence"](http://www.matthewtoews.com/papers/cvpr09-matt.final.pdf) (PDF). _IEEE International Conference on Computer Vision and Pattern Recognition_. pp. 172–177. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1109/CVPR.2009.5206849](https://doi.org/10.1109%2FCVPR.2009.5206849).
25.  **[^](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Sirmacek2009_25-0 "Jump up")** Beril Sirmacek & Cem Unsalan (2009). "Urban Area and Building Detection Using SIFT Keypoints and Graph Theory". _IEEE Transactions on Geoscience and Remote Sensing_. **47** (4): 1156–1167. [Bibcode](https://en.wikipedia.org/wiki/Bibcode_(identifier) "Bibcode (identifier)"):[2009ITGRS..47.1156S](https://ui.adsabs.harvard.edu/abs/2009ITGRS..47.1156S). [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1109/TGRS.2008.2008440](https://doi.org/10.1109%2FTGRS.2008.2008440). [S2CID](https://en.wikipedia.org/wiki/S2CID_(identifier) "S2CID (identifier)") [6629776](https://api.semanticscholar.org/CorpusID:6629776).
26.  **[^](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Se2001_26-0 "Jump up")** Se, S.; Lowe, David G.; Little, J. (2001). ["Vision-based mobile robot localization and mapping using scale-invariant features"](http://citeseer.ist.psu.edu/425735.html). _Proceedings of the IEEE International Conference on Robotics and Automation (ICRA)_. Vol. 2. p. 2051. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1109/ROBOT.2001.932909](https://doi.org/10.1109%2FROBOT.2001.932909).
27.  ^ [Jump up to: <sup><i><b>a</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-SIFTOrientationTrifocal_27-0) [<sup><i><b>b</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-SIFTOrientationTrifocal_27-1) Fabbri, Ricardo; Duff, Timothy; Fan, Hongyi; Regan, Margaret; de Pinho, David; Tsigaridas, Elias; Wampler, Charles; Hauenstein, Jonathan; Kimia, Benjamin; Leykin, Anton; Pajdla, Tomas (23 Mar 2019). "Trifocal Relative Pose from Lines at Points and its Efficient Solution". [arXiv](https://en.wikipedia.org/wiki/ArXiv_(identifier) "ArXiv (identifier)"):[1903.09755](https://arxiv.org/abs/1903.09755) \[[cs.CV](https://arxiv.org/archive/cs.CV)\].
28.  ^ [Jump up to: <sup><i><b>a</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-SIFTOrientationPose_28-0) [<sup><i><b>b</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-SIFTOrientationPose_28-1) Fabbri, Ricardo; Giblin, Peter; Kimia, Benjamin (2012). ["Camera Pose Estimation Using First-Order Curve Differential Geometry"](https://rfabbri.github.io/stuff/fabbri-giblin-kimia-eccv2012-final-ext.pdf) (PDF). _Lecture Notes in Computer Science (ECCV 2012)_. Lecture Notes in Computer Science. **7575**: 231–244. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1007/978-3-642-33765-9\_17](https://doi.org/10.1007%2F978-3-642-33765-9_17). [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)") [978-3-642-33764-2](https://en.wikipedia.org/wiki/Special:BookSources/978-3-642-33764-2 "Special:BookSources/978-3-642-33764-2"). [S2CID](https://en.wikipedia.org/wiki/S2CID_(identifier) "S2CID (identifier)") [15402824](https://api.semanticscholar.org/CorpusID:15402824).
29.  **[^](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Brown2003_29-0 "Jump up")** Brown, M.; Lowe, David G. (2003). ["Recognising Panoramas"](http://graphics.cs.cmu.edu/courses/15-463/2005_fall/www/Papers/BrownLowe.pdf) (PDF). _Proceedings of the ninth IEEE International Conference on Computer Vision_. Vol. 2. pp. 1218–1225. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1109/ICCV.2003.1238630](https://doi.org/10.1109%2FICCV.2003.1238630).
30.  **[^](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Gordon2006_30-0 "Jump up")** Iryna Gordon and David G. Lowe, "[What and where: 3D object recognition with accurate pose](http://www.cs.ubc.ca/labs/lci/papers/docs2006/lowe_gordon.pdf)," in Toward Category-Level Object Recognition, (Springer-Verlag, 2006), pp. 67-82
31.  ^ [Jump up to: <sup><i><b>a</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Flitton2010_31-0) [<sup><i><b>b</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Flitton2010_31-1) Flitton, G.; Breckon, T. (2010). ["Object Recognition using 3D SIFT in Complex CT Volumes"](http://www.durham.ac.uk/toby.breckon/publications/papers/flitton10baggage.pdf) (PDF). _Proceedings of the British Machine Vision Conference_. pp. 11.1–12. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.5244/C.24.11](https://doi.org/10.5244%2FC.24.11).
32.  **[^](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-flitton13interestpoint_32-0 "Jump up")** Flitton, G.T., Breckon, T.P., Megherbi, N. (2013). "A Comparison of 3D Interest Point Descriptors with Application to Airport Baggage Object Detection in Complex CT Imagery". _Pattern Recognition_. **46** (9): 2420–2436. [Bibcode](https://en.wikipedia.org/wiki/Bibcode_(identifier) "Bibcode (identifier)"):[2013PatRe..46.2420F](https://ui.adsabs.harvard.edu/abs/2013PatRe..46.2420F). [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1016/j.patcog.2013.02.008](https://doi.org/10.1016%2Fj.patcog.2013.02.008). [hdl](https://en.wikipedia.org/wiki/Hdl_(identifier) "Hdl (identifier)"):[1826/15213](https://hdl.handle.net/1826%2F15213).`{{[cite journal](https://en.wikipedia.org/wiki/Template:Cite_journal "Template:Cite journal")}}`: CS1 maint: multiple names: authors list ([link](https://en.wikipedia.org/wiki/Category:CS1_maint:_multiple_names:_authors_list "Category:CS1 maint: multiple names: authors list"))
33.  **[^](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Laptev2004_33-0 "Jump up")** Laptev, Ivan & Lindeberg, Tony (2004). ["Local descriptors for spatio-temporal recognition"](http://kth.diva-portal.org/smash/record.jsf?pid=diva2%3A445261&dswid=2390). _ECCV'04 Workshop on Spatial Coherence for Visual Motion Analysis, Springer Lecture Notes in Computer Science, Volume 3667_. pp. 91–103. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1007/11676959\_8](https://doi.org/10.1007%2F11676959_8).
34.  **[^](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Laptev2007_34-0 "Jump up")** Ivan Laptev, Barbara Caputo, Christian Schuldt and Tony Lindeberg (2007). ["Local velocity-adapted motion events for spatio-temporal recognition"](http://kth.diva-portal.org/smash/record.jsf?pid=diva2%3A335153&dswid=8365). _Computer Vision and Image Understanding_. **108** (3): 207–229. [CiteSeerX](https://en.wikipedia.org/wiki/CiteSeerX_(identifier) "CiteSeerX (identifier)") [10.1.1.168.5780](https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.168.5780). [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1016/j.cviu.2006.11.023](https://doi.org/10.1016%2Fj.cviu.2006.11.023).`{{[cite journal](https://en.wikipedia.org/wiki/Template:Cite_journal "Template:Cite journal")}}`: CS1 maint: multiple names: authors list ([link](https://en.wikipedia.org/wiki/Category:CS1_maint:_multiple_names:_authors_list "Category:CS1 maint: multiple names: authors list"))
35.  **[^](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Scovanner2007_35-0 "Jump up")** Scovanner, Paul; Ali, S; Shah, M (2007). "A 3-dimensional sift descriptor and its application to action recognition". _Proceedings of the 15th International Conference on Multimedia_. pp. 357–360. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1145/1291233.1291311](https://doi.org/10.1145%2F1291233.1291311).
36.  **[^](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Niebles2006_36-0 "Jump up")** Niebles, J. C. Wang, H. and Li, Fei-Fei (2006). ["Unsupervised Learning of Human Action Categories Using Spatial-Temporal Words"](http://vision.cs.princeton.edu/niebles/humanactions.htm). _Proceedings of the British Machine Vision Conference (BMVC)_. Edinburgh. Retrieved 2008-08-20.`{{[cite conference](https://en.wikipedia.org/wiki/Template:Cite_conference "Template:Cite conference")}}`: CS1 maint: multiple names: authors list ([link](https://en.wikipedia.org/wiki/Category:CS1_maint:_multiple_names:_authors_list "Category:CS1 maint: multiple names: authors list"))
37.  ^ [Jump up to: <sup><i><b>a</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Toews2010_37-0) [<sup><i><b>b</b></i></sup>](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Toews2010_37-1) Matthew Toews; William M. Wells III; D. Louis Collins; Tal Arbel (2010). ["Feature-based Morphometry: Discovering Group-related Anatomical Patterns"](http://www.matthewtoews.com/papers/matt_neuroimage10.pdf) (PDF). _NeuroImage_. **49** (3): 2318–2327. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1016/j.neuroimage.2009.10.032](https://doi.org/10.1016%2Fj.neuroimage.2009.10.032). [PMC](https://en.wikipedia.org/wiki/PMC_(identifier) "PMC (identifier)") [4321966](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4321966). [PMID](https://en.wikipedia.org/wiki/PMID_(identifier) "PMID (identifier)") [19853047](https://pubmed.ncbi.nlm.nih.gov/19853047).
38.  **[^](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Lazebnik2004_38-0 "Jump up")** [Lazebnik, S.](https://en.wikipedia.org/wiki/Svetlana_Lazebnik "Svetlana Lazebnik"), [Schmid, C.](https://en.wikipedia.org/wiki/Cordelia_Schmid "Cordelia Schmid"), and Ponce, J., "[Semi-Local Affine Parts for Object Recognition](http://hal.archives-ouvertes.fr/docs/00/54/85/42/PDF/bmvc04.pdf)", Proceedings of the British Machine Vision Conference, 2004.
39.  **[^](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Arandjelovic2012_39-0 "Jump up")** Arandjelović, Relja; [Zisserman, Andrew](https://en.wikipedia.org/wiki/Andrew_Zisserman "Andrew Zisserman") (2012). "Three things everyone should know to improve object retrieval". _2012 IEEE Conference on Computer Vision and Pattern Recognition_. pp. 2911–2918. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1109/CVPR.2012.6248018](https://doi.org/10.1109%2FCVPR.2012.6248018).
40.  **[^](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Sungho2006_40-0 "Jump up")** Sungho Kim, Kuk-Jin Yoon, In So Kweon, "Object Recognition Using a Generalized Robust Invariant Feature and Gestalt’s Law of Proximity and Similarity", Conference on Computer Vision and Pattern Recognition Workshop (CVPRW'06), 2006
41.  **[^](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Bay2006_41-0 "Jump up")** Bay, H., Tuytelaars, T., Van Gool, L., "[SURF: Speeded Up Robust Features](http://www.vision.ee.ethz.ch/~surf/eccv06.pdf)", Proceedings of the ninth European Conference on Computer Vision, May 2006.
42.  **[^](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Ke2004_42-0 "Jump up")** Ke, Y., and Sukthankar, R., "[PCA-SIFT: A More Distinctive Representation for Local Image Descriptors](https://www.cs.cmu.edu/~rahuls/pub/cvpr2004-keypoint-rahuls.pdf)", Computer Vision and Pattern Recognition, 2004.
43.  **[^](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Wagner2008_43-0 "Jump up")** D. Wagner, G. Reitmayr, A. Mulloni, T. Drummond, and D. Schmalstieg, "[Pose tracking from natural features on mobile phones](http://mi.eng.cam.ac.uk/~gr281/docs/WagnerIsmar08NFT.pdf) [Archived](https://web.archive.org/web/20090612124616/http://mi.eng.cam.ac.uk/~gr281/docs/WagnerIsmar08NFT.pdf) 2009-06-12 at the [Wayback Machine](https://en.wikipedia.org/wiki/Wayback_Machine "Wayback Machine")" Proceedings of the International Symposium on Mixed and Augmented Reality, 2008.
44.  **[^](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-Henze2009_44-0 "Jump up")** N. Henze, T. Schinke, and S. Boll, "[What is That? Object Recognition from Natural Features on a Mobile Phone](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.149.9089&rep=rep1&type=pdf)" Proceedings of the Workshop on Mobile Interaction with the Real World, 2009.
45.  **[^](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform#cite_ref-45 "Jump up")** ["kaze"](http://www.robesafe.com/personal/pablo.alcantarilla/kaze.html). _www.robesafe.com_.

## External links\[[edit](https://en.wikipedia.org/w/index.php?title=Scale-invariant_feature_transform&action=edit&section=28 "Edit section: External links")\]

**Related studies:**

-   [The Invariant Relations of 3D to 2D Projection of Point Sets, Journal of Pattern Recognition Research](http://www.jprr.org/index.php/jprr/article/view/26)[(JPRR)](http://www.jprr.org/), Vol. 3, No 1, 2008.
-   [Lowe, D. G., “Distinctive Image Features from Scale-Invariant Keypoints”, International Journal of Computer Vision, 60, 2, pp. 91-110, 2004.](http://citeseer.ist.psu.edu/lowe04distinctive.html)
-   [Mikolajczyk, K., and Schmid, C., "A performance evaluation of local descriptors", IEEE Transactions on Pattern Analysis and Machine Intelligence, 10, 27, pp 1615--1630, 2005.](http://lear.inrialpes.fr/pubs/2005/MS05/)
-   ["PCA-SIFT: A More Distinctive Representation for Local Image Descriptors"](https://web.archive.org/web/20200126202031/https://www.cs.cmu.edu/~yke/pcasift/). Archived from [the original](https://www.cs.cmu.edu/~yke/pcasift/) on 26 January 2020.
-   [Lazebnik, S.](https://en.wikipedia.org/wiki/Svetlana_Lazebnik "Svetlana Lazebnik"), [Schmid, C.](https://en.wikipedia.org/wiki/Cordelia_Schmid "Cordelia Schmid"), and Ponce, J., [Semi-Local Affine Parts for Object Recognition, BMVC, 2004.](http://www-cvr.ai.uiuc.edu/ponce_grp/publication/paper/bmvc04.pdf)

**Tutorials:**

-   [Scale-Invariant Feature Transform (SIFT) in Scholarpedia](http://www.scholarpedia.org/article/SIFT)
-   [A simple step by step guide to SIFT](http://www.aishack.in/tutorials/sift-scale-invariant-feature-transform-introduction/)
-   ["SIFT for multiple object detection"](https://web.archive.org/web/20150403120732/http://www.berilsirmacek.com/sift_multiple_object_detection.html). Archived from [the original](http://www.berilsirmacek.com/sift_multiple_object_detection.html) on 3 April 2015.
-   "[The Anatomy of the SIFT Method](http://www.ipol.im/pub/pre/82/)" in Image Processing On Line, a detailed study of every step of the algorithm with an open source implementation and a web demo to try different parameters

**Implementations:**

-   [Rob Hess's implementation of SIFT](https://robwhess.github.com/opensift/) accessed 21 Nov 2012
-   [ASIFT (Affine SIFT)](http://www.ipol.im/pub/algo/my_affine_sift/): large viewpoint matching with SIFT, with source code and online demonstration
-   [VLFeat](http://www.vlfeat.org/api/sift.html), an open source computer vision library in C (with a MEX interface to MATLAB), including an implementation of SIFT
-   [LIP-VIREO](http://pami.xmu.edu.cn/~wlzhao/lip-vireo.htm), A toolkit for keypoint feature extraction (binaries for Windows, Linux and SunOS), including an implementation of SIFT
-   [(Parallel) SIFT in C#](https://sites.google.com/site/btabibian/projects/3d-reconstruction/code), SIFT algorithm in C# using Emgu CV and also a modified parallel version of the algorithm.
-   [DoH & LoG + affine](http://www.mathworks.com/matlabcentral/fileexchange/38782), Blob detector adapted from a SIFT toolbox
-   [ezSIFT: an easy-to-use standalone SIFT implementation in C/C++](https://github.com/robertwgh/ezSIFT). A self-contained open-source SIFT implementation which does not require other libraries.
-   [A 3D SIFT implementation: detection and matching in volumetric images.](http://www.matthewtoews.com/fba/featExtract1.3.zip)
